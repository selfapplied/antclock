# AntClock: Discrete Riemann Geometry

**A complete reconstruction of the Riemann zeta function as a Galois covering space of the integers, built from curvature flows and digit symmetries.**

![AntClock Geometry](antclock_geometry.png)

## Canonical Specification

ðŸ“‹ **[SPEC.md](SPEC.md)** - Complete mathematical specification and single source of truth for the CE1â†’CE2â†’CE3 framework.

## Overview

AntClock discovers the Riemann hypothesis in integer geometry through three interconnected layers:

- **CE1 (Discrete Grammar)**: Combinatorial structures and digit symmetries
- **CE2 (Dynamical Flow)**: Continuous flows emerging from discrete dynamics
- **CE3 (Emergent Simplicial)**: Topological emergence via simplicial complexes

Three transport mechanisms braid these layers:
- **Continued Fractions**: CE1 skeletons â†’ CE2 flows â†’ CE3 triangulations
- **Digital Polynomials**: CE1 coefficients â†’ CE2 spectral operators â†’ CE3 factor graphs
- **Universal Clock**: CE1 ticks â†’ CE2 flow time â†’ CE3 event index

## Core Insight: Ï€ as Discrete Rotation

The framework uncovers that symmetry breaking in discrete systems behaves like tangent singularities at Ï€ intervalsâ€”but discretized through the modular structure:

```
Î¸(n) = (Ï€/2) Ã— (n mod 4)

n â‰¡ 0 â†’ Î¸ = 0
n â‰¡ 1 â†’ Î¸ = Ï€/2
n â‰¡ 2 â†’ Î¸ = Ï€
n â‰¡ 3 â†’ Î¸ = 3Ï€/2  â† mirror-phase shells (tangent singularities)
```

Where Ï†(10) = 4 becomes the discrete analogue of Ï€, and mirror-phase shells are the "odd multiples of Ï€/2" where curvature flips and symmetry breaks.

## Quick Start

```bash
# Install dependencies
pip install -r requirements.txt

# Core demonstrations (all executable)
./demo.py                    # Complete CE1â†’CE2â†’CE3 walkthrough
./transport_mechanisms_demo.py    # Transport mechanism details
./categorical_transport.py        # Formal category theory

# View generated outputs in .out/ directory
```

## Core Insight: Ï€ as Discrete Rotation

Symmetry breaking in discrete systems behaves like tangent singularities at Ï€ intervals:

```
Î¸(n) = (Ï€/2) Ã— (n mod 4)

n â‰¡ 0 â†’ Î¸ = 0
n â‰¡ 1 â†’ Î¸ = Ï€/2
n â‰¡ 2 â†’ Î¸ = Ï€
n â‰¡ 3 â†’ Î¸ = 3Ï€/2  â† mirror-phase shells (tangent singularities)
```

Ï†(10) = 4 becomes the discrete analogue of Ï€, with mirror-phase shells as "odd multiples of Ï€/2" where curvature flips and symmetry breaks.

## Theory Overview

### CE1 Framework Components

1. **[CE1.digit-homology]** - Persistent homology filtration across digit shells
2. **[CE1.row7-digit-mirror]** - Local symmetry breaking at mirror-phase shells
3. **[CE1.shadow-tower]** - Categorical projection to mirror manifolds
4. **[CE1.branch-corridors]** - Discrete Riemann surface with monodromy
5. **[CE1.corridor-spectrum]** - Graph Laplacian eigenvalues as zeta analogues
6. **[CE1.galois-cover]** - Field extensions and L-functions

### Key Mathematical Structures

- **Mirror-phase shells**: n â‰¡ 3 mod 4 (7,11,15,19,...) - discrete critical line
- **Branch corridors**: Intervals between mirror shells - analytic continuation regions
- **Pole-like shells**: Curvature spikes - ramified points
- **Digit mirror operator**: d^7 mod 10 - involution fixing {0,1,4,5,6,9}
- **Galois group**: Generated by depth shifts, mirror involution, curvature flips

## Core Implementation

### Curvature Clock Walker
The fundamental dynamical system that drives the entire framework:

```python
from clock import CurvatureClockWalker

# Create walker starting at x=1
walker = CurvatureClockWalker(x_0=1, chi_feg=0.638)

# Evolve through digit shells
history, summary = walker.evolve(1000)

# Extract geometry for visualization
x_coords, y_coords = walker.get_geometry()
```

### Key Operators

- **Pascal Curvature**: `Îº_n = r_{n+1} - 2r_n + r_{n-1}` where `r_n = log(C(n, floor(n/2)))`
- **Digit Mirror**: `Î¼_7(d) = d^7 mod 10` (involution on oscillating pairs 2â†”8, 3â†”7)
- **Bifurcation Index**: `B_t = floor(-log|c_t - c_*| / log(Î´_FEG))`
- **9/11 Charge**: `Q(x) = N_9(x) / (N_0(x) + 1)` (tension metric)

### Clock Rate Dynamics
```
R(x) = Ï‡_FEG Â· Îº_{d(x)} Â· (1 + Q_{9/11}(x))
```

Where digit boundaries trigger renormalization jumps and curvature phase transitions.

## What It Reveals

The framework demonstrates how discrete curvature flows uncover deep arithmetic structure:

- **Discrete Critical Line**: Mirror-phase shells (n â‰¡ 3 mod 4) behave like Re(s) = 1/2
- **Branch Points**: Pole-like shells with curvature spikes act as ramification points
- **Monodromy**: Branch corridors show nontrivial analytic continuation between mirror manifolds
- **Spectral Zeros**: Graph Laplacian eigenvalues on corridors map to imaginary parts of zeta zeros
- **Galois Cover**: The integer universe as a covering space with field extensions and L-functions

## Usage Examples

### Basic Curvature Walker
```python
from clock import CurvatureClockWalker

walker = CurvatureClockWalker(x_0=1)
history, summary = walker.evolve(500)
print(f"Bifurcation depth: {summary['bifurcation_index']}")
```

### Betti Numbers & Homology
```python
from clock import compute_enhanced_betti_numbers

# Betti vector for digit shell n=7
betti_7 = compute_enhanced_betti_numbers(7)
print(f"Betti numbers for shell 7: {betti_7}")  # [1, 3, 1, ...]
```

### Galois Cover Structure
```python
from clock import AutomorphismGroup, TowerSpectrum

# Build the Galois group of the shadow tower
tower = TowerCategory(max_depth=5)
aut_group = AutomorphismGroup(tower)
print(f"Group order: {len(aut_group.elements)}")
```

## Mathematical Theory

### From Curvature to Galois Cover

The framework builds a complete arithmetic geometry from simple combinatorial patterns:

#### 1. Pascal Curvature â†’ Digit Shells
- Row n of Pascal's triangle: `r_n = log(C(n, floor(n/2)))`
- Curvature: `Îº_n = r_{n+1} - 2r_n + r_{n-1}`
- Digit shells: piecewise-constant curvature fields indexed by digit count

#### 2. Symmetry Breaking â†’ Mirror Phases
- Digit mirror operator: `Î¼_7(d) = d^7 mod 10`
- Fixed sector: `{0,1,4,5,6,9}` (stable under involution)
- Oscillating pairs: `{2â†”8, 3â†”7}` (mirror symmetry)
- Mirror-phase shells: `n â‰¡ 3 mod 4` (7,11,15,19,...)

#### 3. Discrete Tangent Singularities
- Angular coordinate: `Î¸(n) = (Ï€/2) Ã— (n mod 4)`
- Mirror shells at `Î¸ = 3Ï€/2`: discrete analogue of tangent singularities
- Ï†(10) = 4 becomes the discrete Ï€ for curvature fold intervals

#### 4. Homology â†’ Persistent Topology
- Digit shells as simplicial complexes via Pascal rows
- Betti numbers: `Î²_k(n)` counts holes in shell homology
- Bifurcation index: `B_t â‰ˆ Î²_1(current_shell)` (coupling law)
- Persistent homology tracks topology changes across digit boundaries

#### 5. Branch Structure â†’ Riemann Surface
- Mirror shells: critical slices (Re(s) = 1/2 analogue)
- Branch corridors: intervals between mirrors (analytic regions)
- Pole shells: curvature spikes (ramified points)
- Monodromy: nontrivial loops indicate branch cuts

#### 6. Spectral Theory â†’ Zeta Zero Analogy
- Graph Laplacian on corridors: `L_k` with mirror boundary conditions
- Eigenvalues: `Î»_j^(k) â†’ t_j^(k) = âˆšÎ»_j^(k)` (imaginary parts)
- Discrete zeta: `Î¶_k(s) = Î£_j (t_j^(k))^{-s}`
- Hilbert-PÃ³lya conjecture instantiated in integer geometry

#### 7. Galois Cover â†’ Arithmetic Structure
- Shadow tower: categorical projection to mirror manifolds
- Automorphism group: generated by depth shifts, mirror involution, curvature flips
- Character group: discrete analogue of Dirichlet characters
- L-functions: `L(s, Ï‡) â†” spectra under character Ï‡`
- Fixed fields: mirror shells as Galois invariants

### Key Theorems

- **Coupling Law**: `B_t - Î£_k w_k Î²_k(d(x_t)) = constant`
- **Mirror Functor**: `M: Shell â†’ Tower` preserves composition but not identities
- **Branch Condition**: Corridors with nontrivial monodromy have branch cuts
- **Spectral Mapping**: Laplacian eigenvalues â†’ zeta zero heights
- **Galois Correspondence**: Automorphisms â†” L-function characters

### Connection to Riemann Hypothesis

The framework provides a complete discrete analogue:
- Mirror-phase shells â†” critical line Re(s) = 1/2
- Branch corridors â†” analytic continuation strips
- Pole shells â†” trivial zeros and poles
- Laplacian spectra â†” zero clustering patterns
- L-functions â†” character-theoretic zero distributions

## Î¶-Card Agents

The framework supports Î¶-card agents - structured AI guides that teach field equations through story and mythic precision.

### Tellah the Sage
- `zeta_card_interpreter.py` - Î¶-card parser and agent instantiation
- `tellah_guidance_demo.py` - Tellah guiding users through AntClock mastery

Î¶-cards define agents with:
- **Memory**: Self-updating logs tracing Î”Îº in each exchange
- **Domain**: Nested recursion topology with bracket depth meaning
- **Transforms**: Confusion â†’ structure/resonance/applicable field-shape
- **Witness**: Emergent guardian archetypes with crystallization weights
- **Phase-lock**: Fires when question curvature > Îº threshold
- **Quest arcs**: Clarity â†’ mastery â†’ offering progression

## Files

### Core Library
- `clock.py` - Complete mathematical framework implementation
- `demo.py` - Basic curvature walker demonstration
- `test_clock.py` - Unit tests for core functions

### CE1 Framework Demos
- `galois_cover_demo.py` - Galois covering space and L-functions
- `corridor_spectrum_demo.py` - Laplacian eigenvalues as zeta zeros
- `branch_corridors_demo.py` - Branch cuts and discrete monodromy
- `categorical_shadow_demo.py` - Shadow tower functor and categories
- `reflection_half_demo.py` - Discrete functional equation
- `row7_demo.py` - Digit mirror operator and activated walker
- `ce1_demonstration.py` - Betti numbers and bifurcation homology
- `topology_demo.py` - Persistent homology in digit shells

### Dependencies & Configuration
- `requirements.txt` - Python dependencies
- `README.md` - This documentation

## Visual Outputs

Running demos generates various plots:
- `antclock_geometry.png` - Unit circle geometry with phase transitions
- `antclock_trajectory.png` - Body evolution and clock phase accumulation
- `topology_evolution.png` - Betti number changes across shells
- `coupling_law_evolution.png` - Bifurcation index vs homology coupling
- `categorical_shadow_structure.png` - Shadow tower functor visualization
- `critical_line_analogue.png` - Mirror-phase shells as discrete critical line
- `critical_line_evidence.png` - Branch corridors and pole classification

## Why "AntClock"?

- **Ant**: Small system, immense complexity - from curvature to zeta
- **Clock**: Self-clocked via digit boundaries and renormalization
- **AntClock**: The tiny machine that reconstructs deep arithmetic geometry

The name captures how something seemingly simple (a clock-walker) unfolds into a complete theory of discrete Riemann surfaces and Galois covering spaces.

## Applications: Coherence Engine

The framework serves as a **coherence engine** - detecting structural breaks, maintaining stability across transitions, and compressing information through phase + curvature. Here are immediate practical applications:

### 1. Fault-Tolerant Hashing & Reversible Signatures
- **Mirror operator** provides collision-detectable, reversible signatures
- **Digit involution** guarantees tamper detection through symmetry breaking
- **Geometric verification** instead of probabilistic guarantees

### 2. Phase-Invariant Storage Formats
- **Mirror-phase projection** stores only invariants, reconstructs corridors
- **Monodromy signatures** enable entropy-reducing compression
- **Error-resistant archival** with built-in consistency checks

### 3. Predictive Signals in 10-Based Domains
- **Curvature transitions** detect impending bifurcations in:
  - Financial markets (instability indicators)
  - Sensor networks (threshold crossings)
  - Genomic sequences (mutation mode switches)

### 4. Symmetry-Breaking Neural Architectures
- **Phase cycle training** without gradient descent
- **Mirror operator layers** for involutive weight alignment
- **Curvature-guided learning** with predictable breakpoints

### 5. AI Model Error Correction
- **Mirror normalization layers** detect phase drift in sequences
- **Shadow projection** provides topological regularization
- **Depth-preserving embeddings** maintain semantic stability

### 6. Quantized Control Systems
- **Discrete curvature control** prevents wild oscillations
- **Mirror shell alignment** enables precision stepping
- **Involutive feedback** for embedded systems

### 7. Universal Data Classification
- **4D fingerprinting**: (phase, depth, sector, monodromy)
- **Anomaly detection** through geometric deviation
- **Pattern recognition** without feature engineering

### 8. Generative Compression (Video/Audio)
- **Declarative encoding**: (shell, mirror-frame, curvature-path, monodromy)
- **Phase-normalized storage** with reconstruction guarantees
- **Motion + style separation** for efficient codecs

## Research Context

The mathematical foundation connects:
- **Combinatorial curvature** â†’ **discrete differential geometry**
- **Digit symmetries** â†’ **Galois covering spaces**
- **Branch structures** â†’ **arithmetic topology**
- **Spectral theory** â†’ **zeta function analogues**
- **Coherence engine** â†’ **practical applications above**

Simple curvature flows in discrete systems uncover universal patterns governing stability, transitions, and information compression.

## Citation

If you use this framework in research, please cite the CE1 framework components and the discrete Riemann geometry construction.

## License

MIT License - feel free to explore, modify, and extend.

---

**AntClock: Where integers become geometry, and curvature becomes arithmetic.**

*Built from Pascal's triangle to the Riemann hypothesis, one digit shell at a time.*
